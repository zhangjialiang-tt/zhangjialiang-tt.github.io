<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2018%2F10%2F21%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[基于FPGA图像预处理基础知识]]></title>
    <url>%2F2018%2F10%2F19%2F%E5%9B%BE%E5%83%8F%E9%A2%84%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[图像预处理的基本步骤 导入图像 去噪处理——图像滤波（中值滤波） 图像增强 彩色图像转变成灰度图 灰度图转化成二值图 边缘检测/分割——Sobel算子 直方图匹配/轮廓匹配 窗处理FPGA图像处理系列——实现窗处理 ref2 中值滤波中值滤波基于排序统计理论，是抑制噪声的非线性信号处理技术。 先看效果： 原理：核心运算是对窗口模板中的数据进行排序, 使得某个亮点 (暗点)的噪声在排序过程中被排在数据序列的两侧，从而用该像素邻域中的中间值替代这个亮/暗点（噪声），即剔除了噪声。 标准中值滤波基本思路：标准中值滤波对邻域中的像素按灰度级进行排序, 然后选择该组的中间值作为输出像素值。 缺点：标准中值滤波对平均分布的噪声抑制效果差, 对脉冲声有较好的抑制效果。 也就是：中值滤波是针对一幅图像的所有像素，（灰度值较大/较小的）噪声很容易被排序排到两端，但是正常像素点也被中值滤波器进行了排序，本来是排在第二位的像素有可能被第6个位子的像素替代，这种对正常像素的平滑是中值滤波器的副作用。 由中值滤波算法的定义可推知, 在 n× n 的滤波窗口内, 若噪声像素点的数量大于 n (n+1)/ 2, 则该噪声不会被滤除, 为了提高中值滤波的去噪效果, 必须增大滤波器窗口。 另一方面, 若窗口中的图像边缘细节的像素数小于 n(n+1)/2 , 则该细节像素将会被其他像素的灰度值取代, 造成了图像细节的模糊 。为了保护图像细节边缘, 又要求缩小滤波窗口, 这是标准中值滤波算法的一个矛盾。 滤波器整体结构的 FPGA 设计图像滤波器的结构 滤波窗口生成模块、； 行列计数器模块； 滤波算法模块； 滤波窗口生成模块——窗处理图像预处理算法往往针对邻域像素操作。 以 3 ×3 的窗口为例,，利用 2 个 FIFO 和 6 个寄存器对图像的行、 列数据进行存储, 设计滤波窗口如图 1 所示。 每个 FIFO 的地址长度为图像的宽度，即 1 个FIFO 存储 1 行图像数据, 用于图像行数据缓存; 6 个寄存器分 3 组两两串接, 实现每行数据上列像素的缓存, 从而形成一个 3×3 的滤波窗口 , 在一个像素时钟周期内并行输出 9 个数据作为后续算法模块的输入。 图像行列计数器设计对二维图像进行邻域操作时, 随着窗口的滑动, 中心像素将运动到图像的边缘, 但边缘点是不存在邻域的, 故此时滤波窗口输出的邻域数据是无意义的。 图 2 所示是滤波窗口变化过程, 窗口从 (a)到 (d)变化的过程中, (b) 和 (c)所示的窗口均是无意义的。 通常, 图像边缘不包含重要信息, 很多处理算法将边缘点取为零, 因此要设计地址计数器和控制逻辑判断当前被处理像素的位置。 对于一幅 M ×N 的图像, 设计计数控制模块如图 3 由图 3 可知, 当行计数值 i =1 或 i =M , 或列计数值 j =1或 j =N , 即滤波窗口中心像素处于图像边缘时, 直接将输出信号置为零, 而在其它时刻则输出算法模块的滤波值。对于实时采集输入的图像数据流, 可以采取的计数方法是:在行有效期间以像素时钟对 j 进行计数, 在行消隐期间对j 复位;在场有效期间以行有效同步信号对 i 进行计数, 在场消隐期间对 i 复位。 滤波算法设计中值滤波基本思路：获取图像数据的 3×3 窗口后，九个像素的灰度值经过6级比较电路，完成灰度值排序，最后输出中值。 输入数据为滤波掩膜所在的图像数据。 第一级比较电路由3 个三输入比较器 C 组成, 每个比较器的输出数据依序排列 (参见图示)。 将 3 组比较结果中最小的3 个数放在一起、 中间的 3 个数放在一起、 最大的 3 个数放在一起, 参加第二级比较。 第二级比较电路的输入分别是第一级输出的最大值、中间值、最小值（找到最大值中的最大值，最小值中的最小值，中间值中的中间值），输出 out1 和 out9 分别是输入数据中的最大值和最小值，这 2 个数据将被舍去不参加下一级比较。 参加第三级比较的有7 个数据, 其原理类似于前两级比较电路, 输出 out2 和out8 分别是该 7 个数据的最大值和最小值, 并且被舍去, 仅留下 5 个数据参加第四级比较。 剩下的几级比较电路以类似于先前的原理进行比较。 如此, 经过 6 级比较后即可得到 9 个数据的标准中值滤波输出值 out5（out5是中间值中的中间值，所以这叫做中值滤波算法） , 而 out1 , out2 , … , out9 分别是这 9 个数据从最大到最小的顺序排列值。 此外, 为了保证流水线操作过程中数据的同步性, 在第三级和第五级比较电路中需要插入数据寄存器 R 缓存当前该级中不参与比较的数据。 放一张图示意下排序算法是过程： Task: FPGA实现窗处理 Sobel算法原理 …… [^2]:]]></content>
      <categories>
        <category>FPGA</category>
        <category>数字图像处理</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SystemVerilog--数据类型]]></title>
    <url>%2F2018%2F10%2F19%2FSystemVerilog-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[SystemVerilog–数据类型[TOC] 基本数据类型Verilog中的变量是四状态的——0, 1, X, Z，System Verilog引入双状态数据，这有助于提高仿真速度。 注意:进行逻辑设计时最好还是使用四状态数据，这样能实现高阻态和未知态。 123bit [15:0] bus_A; // Default unsignedbit signed [15:0] bus_A; // declared as signed 数组定宽数组 数组在声明时必须给出上下界，可以使用类似C语言的方式声明。 12int arr1[0:15];//16个整数int arr2[16];//16个整数 多维数组。 123int arr3[0:7][0:3];//完整的声明int arr4[8][4];//紧凑的声明arr5[7][3] = 1;//设置最后一个元素 数组赋值。使用单引号+大括号来初始化数组 1234567int arr6[4] = '&#123;0,1,2,3&#125;;//对四个元素进行初始化int arr7[5];arr7 = '&#123;4,3,2,1,0&#125;;//为5个元素赋值arr7[0:2] = '&#123;5,6,7&#125;;//为前3个元素赋值arr6 = '&#123;4&#123;8&#125;&#125;;//4个值全为0arr7 = '&#123;9,8,default:1&#125;; 基本的数组操作 for和foreach循环 123456789initial begin bit[31:0] src[5],dst[5]; for(int i = 0; i &lt; $size(src); i = i+1) begin src[i] = i; end foreach( dst[j] )//遍历dst数组 dst[j] = src[j]*2;end 动态数组动态数组在仿真时调整分配空间或者调整宽度，编译时不给出数组宽度，运行时确定，所以使用new[]操作符分配空间，同时括号中给出数组宽度。 12345678910111213int dyn[],d2[]; //声明动态数组initial begin dyn = new[5]; //A:分配5各元素 foreach ( dyn[j] ) //B:对元素进行初始化 dyn[j] = j; d2 = dyn; //C:复制一个动态数组 d2[0] = 5; //D:修改赋值值 $display(dyn[0],d2[0]); //E:显示数组 dyn = new[20](dyn); //F:分配20个整数，并复制原来的5个数给新的数组 dyn = new[100]; //G:分配100个整数 dyn.delete(); //H:删除所有元素end 队列队列是SV引进的新数据类型，结合数组和链表的有点： （像链表）在队列的任何地方增加或者删除元素，而动态数组需要先分配空间并复制原来的数； （像数组）可以通过索引访问任何一个元素，而不用像链表需要遍历所有元素； 1234567891011121314151617int j = 1;q2[$] = &#123;3,4&#125;; //队列的常量不需要使用"'"q[$] = &#123;0,2,5&#125;;initial begin q.insert(1,j); //在2前插入1 q.insert(3,q2); //在q中插入一个队列 q.delete(1); //删除第一个元素 q.push_front(6); //在队列前插入 j = q.pop_back; //j=5 q.push_back(8); //在队列末尾插入 j = q.pop_front; //j=6 foreach( q[i] ) //打印整个队列 $display(q[i]); q.delete(); //删除整个队列end]]></content>
      <categories>
        <category>FPGA</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>SystemVerilog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CAN总线协议]]></title>
    <url>%2F2018%2F10%2F19%2FCAN%E6%80%BB%E7%BA%BF%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[CAN总线协议1.简介CAN总线由德国BOSCH公司开发，最高速率可达到1Mbps。CAN的容错能力特别强，CAN控制器内建了强大的检错和处理机制。另外不同于传统的网络（比如USB或者以太网），CAN节点与节点之间不会传输大数据块，一帧CAN消息最多传输8字节用户数据，采用短数据包也可以使得系统获得更好的稳定性。CAN总线具有总线仲裁机制，可以组建多主系统。 总结： 两根信号线，差分信号 最高速率可达到1Mbps CAN控制器内建了强大的检错和处理机制，容错能力强 一帧CAN消息最多传输8字节用户数据 具有总线仲裁机制，可以组建多主系统 2 CAN标准 ISO-11898:2003 在图2-1中，应用程序层建立了上层应用特定协议，如CANopenTM协议的通讯链路。这个协议由全世界的用户和厂商组织、CiA维护，详情可访问CiA网站。许多协议是专用的，比如工业自动化、柴油发动机或航空。另外的工业标准例子，是基于CAN的协议的，由KVASER和Rockwell自动化开发的DeviceNetTM。 3. CAN通信协议特征 载波侦听（CSMA）：总线上的每一个节点在企图发送报文前，必须要监听总线，当总线处于空闲时，才可发送 仲裁（CD+AMP）：通过预定编程好的==报文优先级==逐位仲裁来解决碰撞，报文优先级位于每个报文的标识域。更高级别优先级标识的报文总是能获得总线访问权，即：标识符中最后保持逻辑高电平的会继续传输，因为它具有更高优先级。 标准CAN只有11位标识符，每帧的数据长度为51+（064）=（51117）位。注：不计位填充 标识符：标准CAN具有11位标识符，用来确定报文的优先级。此域的数值越小，优先级越高 SOF - 帧起始，显性（逻辑0）表示报文的开始，并用于同步总线上的节点。 标识符 - 标准CAN具有11位标识符，用来确定报文的优先级。此域的数值越小，优先级越高。 RTR - 远程发送请求位，当需要从另一个节点请求信息时，此位为显性（逻辑0）。所有节点都能接收这个请求，但是帧标识符确定被指定的节点。响应数据帧同样被所有节点接收，可以被有兴趣的节点使用。 IDE - 标识符扩展位为显性时表示这是一个标准CAN格式，为隐形表示这是扩展CAN格式。 r0 - 保留位（可能将来标准修订会使用） DLC - 4位数据长度代码表示传输数据的字节数目，一帧CAN最多传输8字节用户数据 数据0~8 – 最多可以传输8字节用户数据 CRC - 16位（包括1位定界符）CRC校验码用来校验用户数据区之前的（包含数据区）传输数据段。 ACK - 2位，包含应答位和应答界定符。发送节点的报文帧中，ACK两位是隐性位，当接收器正确地接收到有效的报文，接收器会在应答位期间向发送节点发送一个显性位，表示应答。如果接收器发现这帧数据有错误，则不向发送节点发送ACK应答，发送节点会稍后重传这帧数据。 EOF – 7位帧结束标志位，全部为隐性位。如果这7位出现显性位，则会引起填充错误。 IFS – 7位帧间隔标志位，CAN控制器将接收到的帧正确的放入消息缓冲区是需要一定时间的，帧间隔可以提供这个时间。 扩展CAN具有29位标识符，每帧数据长度为71+（064）=（71135）位。注：不计位填充 扩展CAN消息相对于标准CAN消息增加的内容如下： SRR – 代替远程请求位，为隐性。所以当标准帧与扩展帧发送相互冲突并且扩展帧的基本标识符与标准帧的标识符相同时，标准帧优先级高于扩展帧。 IDE – 为隐性位表示标志位扩展帧，18位扩展标识符紧跟着IDE位。 r1 – 保留 4.CAN消息消息类型CAN有四种不同的报文类型：数据帧、远程帧、错误帧、遥控帧和过载帧。 5.网络拓扑高速ISO 11898标准规定了CAN传输最高速率为1Mbps，在这个速率下，传输距离最长40米（挂接30个节点，CAN信号不隔离）。推荐节点分支长度最大为0.3米、推荐使用带屏蔽或不带屏蔽的双绞线，线缆特性阻抗为120欧姆。 使用差分信号 推荐使用双绞线]]></content>
      <categories>
        <category>FPGA</category>
        <category>总线</category>
      </categories>
      <tags>
        <tag>总线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于FPGA的Sobel边沿检测实现]]></title>
    <url>%2F2018%2F10%2F19%2F%E5%9F%BA%E4%BA%8EFPGA%E7%9A%84Sobel%E8%BE%B9%E6%B2%BF%E6%A3%80%E6%B5%8B%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[[翻译]基于FPGA的Sobel边沿检测实现ScienceDirect 1.Introduction边缘（Edge）是一幅图像上强度发生显著变化的地方。找到边缘可以帮助识别对象的位置和图像中特定实体的边界。在特征提取（Feature Extraction）和模式识别（Pattern Recognition）方面也是大有帮助。因此，边缘检测在计算机视觉方面非常重要。到目前为止，大多数研究人员都选择使用软件实现基本的边缘检测算法和一些变形算法。但是，这些方法已经被确定不是有效的实时应用系统的实现。边缘检测算法在硬件平台上的实现对于实时性更加高效。随着超大规模集成技术的发展，硬件实现为软件中并行处理子程序的实现提供了一种方法。因此，硬件实现相对于软件来说，提供了更快的可替代方法。1994年Boo等人提出了使用VLSI技术在ASIC中使用Sobel算子来进行边沿检测的硬件实现。在过去的几年中，使用FPGA实现边沿检测算法的研究反过促进了实时图像处理的研究。在2009年时设计了实时算法，在FPGA板子上进行边缘检测，使用VLSI技术，在一颗硅片上集成10K-100K的晶体管，任何算法的并行化都有可能实现。所有的嵌入式系统都在ASIC或FPGA上设计与实现。 FPGA是一种具有可配置逻辑块(CLBs)的IC。根据需要的操作，CLB使用硅片上的路由通道进行互联。内部连接可以使用硬件描述语言(HDL)进行配置，比如VHDL或Verilog。如图一所示，硅片由输入/输出端口组成，在边界上提供输入和输出。Abbasi等人在2007年提出了一种在FPGA上实现Sobel边缘检测的架构。在2012年，这个架构被Halder等人证明在空间和时间复杂度方面效率很低。他们提出了一种时间和时间空间复杂度小于Abbasi等人的体系结构。然而，这个架构在像素的冗余存储方面也有缺点，这种架构的精简的实现方法。本文的目的就是克服这些缺点。 目前工作领域的贡献如下: 为了降低卷积过程中的空间复杂度，提出了一种8位结构来检索卷积过程中所涉及像素的地址。 为了降低Sobel边缘检测算法的时间复杂度，通过替换Halder等人提出的体系结构中的一些组件来改进体系结构。 本文的组织如下。第2节简要介绍了Sobel边缘检测算法。第3节提出了传统的Sobel边缘检测算法的改进版本。第4节描述了本文所采用的方法。第5节给出了实验结果和讨论。最后，第6节总结了这项工作。 2.Sobel边沿检测算法Sobel边缘检测算法是一种基于梯度的边缘检测方法，采用水平掩码(HM)和垂直掩码(VM)进行边缘检测。一个掩模是另一个的转置，如下所示：$$VM=\begin{bmatrix} -1&amp;-2&amp;-1\\\ 0&amp;0&amp;0\\\ 1&amp;2&amp;1 \end{bmatrix} $$ $$HM=\begin{bmatrix} -1 &amp;0&amp;1\\\ -2&amp;0&amp;2\\\ -1&amp;0&amp;1 \end{bmatrix} $$ 对于卷积过程，分别使用HM和VM对图像从左到右、从上到下进行扫描。卷积是将图像的每一个强度值与它的局部邻居相乘，用掩模加权的过程。让$ {P}_{3*3}$的成为一幅图像的sub-window，如图2中，分别与HM和VM进行卷积。 由Eqs给出子窗口中心像素(P4)的水平梯度Gx和垂直梯度Gy。(1)和(2)分别。$$G_x = f_1- f_2\tag{1}$$ $$其中，f_1 = (P_6+2×P_7+P_8),f_2 = (P_0+2×P_1+P_2)$$ $$G_y = f_3- f_4\tag{2}$$ $$其中，f_3 = (P_2+2×P_5+P_8),f_4 = (P_0+2×P_3+P_6)$$ 子窗口中心像素的合成梯度为：$$G =|G_x|+|G_y|\tag{3}$$通过与预定义的阈值进行比较，进一步利用P4的梯度来确定它是否是边缘像素。如果P4的梯度大于阈值，则将P4视为边缘像素(记为1)，否则将P4视为非边缘像素(记为0)，如式4所示。$$D_op =\begin{cases}1 \qquad &amp; if G \gt t \0 \qquad &amp; otherwise\end{cases}\tag{4}$$ 3.传统Sobel边沿检测算法的简化传统的Sobel边缘检测算法需要做一些调整，因为在硬件实现上采用了8位架构。Halder等人对传统算法进行了简化，Halder等人提出的算法简化版本做了一些修改。在Eq.(1)中，当子窗口的每个贡献像素都有最大的强度值时，f1和f2的值最大，即255。同样发生在f3,f4 。所以f1,f2,f3,f4 的最大可能值是4×255,因此它需要10位架构实现。为了解决这个问题，f1, f2, f3和f4的值被限制在原来值的四分之一。因此，在计算f1、f2、f3和f4的值之前，每个贡献的像素必须除以4，如Eqs所示。(5)-(8)。$$f_1 = \frac{1}{4}P_6+\frac{1}{4}P_7+\frac{1}{4}P_8\tag{5}$$ $$f_2 = \frac{1}{4}P_0+\frac{1}{4}P_1+\frac{1}{4}P_2\tag{6}$$ $$f_3 = \frac{1}{4}P_2+\frac{1}{4}P_5+\frac{1}{4}P_8\tag{7}$$ $$f_4 = \frac{1}{4}P_0+\frac{1}{4}P_3+\frac{1}{4}P_6\tag{8}$$ 由于同样的原因，Gx和Gy必须除以2，G的新方程为:]$$G =\frac{1}{2}|G_x|-\frac{1}{2}|G_y|\tag{9}$$公式1~3可以写为：$$G_x = f_1- f_2\tag{10}$$ $$其中，f_1 = (\frac{1}{8}P_6+\frac{1}{4}P_7+\frac{1}{8}P_8),f_2 = (\frac{1}{8}P_0+\frac{1}{4}P_1+\frac{1}{8}P_2)$$ $$G_y = f_3- f_4\tag{11}$$ $$其中，f_3 = (\frac{1}{8}P_2+\frac{1}{4}P_5+\frac{1}{8}P_8),f_4 = (\frac{1}{8}P_0+\frac{1}{4}P_3+\frac{1}{8}P_6)$$ 由于Gx和Gy的绝对值是在Eq.(3)中计算出来的，所以需要考虑以下四种情况。 Case 1: If both Gx and Gy are positive——$G_1 = f_5 - f_6$ Case 2: If Gx is positive and Gy is negative.——$G_2 = f_7 - f_8$ Case 3: If Gx is negative and Gy is positive.——$G_3 = f_8 - f_7$ Case 4: If Gx and Gy are both negative.——$G_4 = f_6 - f_5$ 在特定的时刻，四分之一的情况是正确的，其余的情况是错误的。假设，如果情形1为真，那么f1和f3分别大于或等于f2和f4。因此，在这种情况下，G1是最大的，它被认为是子窗口中心像素(P4)的合成梯度G。这四种情况互不相容。反过来，可以观察到G的值将是4个可能值的最大值，可以用公式(16)表示。$$G = max(G_1,G_2,G_3,G_4)=max(|f_5-f_6|,|f_7-f_8|)=max(f_9,f_10)\tag{16}$$ 4.方法论5.实验结果及分析6.结论]]></content>
      <categories>
        <category>FPGA</category>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>FPGA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建博客]]></title>
    <url>%2F2018%2F10%2F18%2FHexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo搭建博客环境准备 Git。 Git官网地址、Git for Windows 国内下载站 检查是否安装成功。git version 配置Git。在GitBash中配置GitHub账户信息 配置账号——git config --global user.name &quot;my_account_name&quot; 配置邮箱——git config --global user.email my_qq_email 创建SSH。在gitbash中输入：ssh-keygen -t rsa -C &quot;youremail@example.com，生成SSH。然后在.ssh文件夹下找到id_rsa.pub文件，把里面的内容复制到GitHub→“创建SSH Keys”。 在gitbash中验证是否添加成功：ssh -T git@github.com Node.js 官网地址 查看版本。node -v 配置NPM为国内下载镜像——淘宝 NPM 镜像，命令行替代：使用cnpm替代npm。 npm install -g cnpm --registry=https://registry.npm.taobao.org Hexo 先创建一个文件夹（用来存放所有blog的东西），然后在GitBash中cd到该文件夹下。 安装Hexo命令：cnpm i -g hexo 安装完成后，查看版本：hexo -v 初始化命令：hexo init 搭桥到GitHub在GitHub账户里创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称。 打开my_repo—_config.yml文件，修改配置： 1234deploy: type: git repo: https://github.com/Your_github_Name/Your_github_Name.github.io.git branch: master 回到gitbash中，进入你的blog目录，分别执行以下命令： hexo clean hexo generate hexo server 在GitHub中安装：npm i hexo-server 打开浏览器输入：http://localhost:4000就可以看到自己搭建的博客了。 Hexo常用命令inithexo init [folder] new hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate生成静态文件hexo generate 简写为 hexo g server——启动服务器hexo server 简写为 hexo s deployhexo deploy 部署网站。 简写为 hexo d hexo d -g #部署前生成静态文件 clean——清除缓存文件Hexo备忘总结 在首页不全部显示，有个“阅读全文按钮”。在想要显示的源码问价那种输入&lt;!--more--&gt;，即可按照Markdown渲染后的样式显示在主页。 给笔记添加标签/分类。在笔记开头插入“Head Fornt”。 YAML 12345678910title: Hello Worlddate: 2013/7/13 20:46:25categories:- cat1- cat2tags:- tag1- tag2- tag3--- 也可以使用数组样式的Tags 12345categories:- [Sports, Baseball]- [MLB, American League, Boston Red Sox]- [MLB, American League, New York Yankees]- Rivalries]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown For Typora]]></title>
    <url>%2F2018%2F10%2F18%2FMarkdown-For-Typora%2F</url>
    <content type="text"><![CDATA[Markdown For TyporaOverviewMarkdown is created by Daring Fireball, the original guideline is here. Its syntax, however, varies between different parsers or editors. Typora is using GitHub Flavored Markdown. Outline [TOC] Block ElementsParagraph and line breaksA paragraph is simply one or more consecutive lines of text. In markdown source code, paragraphs are separated by more than one blank lines. In Typora, you only need to press Return to create a new paragraph. Press Shift + Return to create a single line break. However, most markdown parser will ignore single line break, to make other markdown parsers recognize your line break, you can leave two whitespace at the end of the line, or insert &lt;br/&gt;. HeadersHeaders use 1-6 hash characters at the start of the line, corresponding to header levels 1-6. For example: 12345# This is an H1## This is an H2###### This is an H6 In typora, input ‘#’s followed by title content, and press Return key will create a header. BlockquotesMarkdown uses email-style &gt; characters for block quoting. They are presented as: 1234567&gt; This is a blockquote with two paragraphs. This is first paragraph.&gt;&gt; This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. This is a blockquote with two paragraphs. This is first paragraph. This is second pragraph.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. This is another blockquote with one paragraph. There is three empty line to seperate two blockquote. In typora, just input ‘&gt;’ followed by quote contents a block quote is generated. Typora will insert proper ‘&gt;’ or line break for you. Block quote inside anther block quote is allowed by adding additional levels of ‘&gt;’. ListsInput * list item 1 will create an un-ordered list, the * symbol can be replace with + or -. Input 1. list item 1 will create an ordered list, their markdown source code is like: 123456789## un-ordered list* Red* Green* Blue## ordered list1. Red2. Green3. Blue Task ListTask lists are lists with items marked as either [ ] or [x] (incomplete or complete). For example: 12345- [ ] a task list item- [ ] list syntax required- [ ] normal **formatting**, @mentions, #1234 refs- [ ] incomplete- [x] completed [ ] a task list item [ ] list syntax required [ ] normal formatting, @mentions, #1234 refs [ ] incomplete [x] completed - [ ] You can change the complete/incomplete state by click the checkbox before the item. (Fenced) Code BlocksTypora only support fences in Github Flavored Markdown. Original code blocks in markdown is not supported. Using fences is easy: Input ``` and press return. Add an optional language identifier after ``` and we’ll run it through syntax highlighting: 1234567891011121314Here&apos;s an example:```function test() &#123; console.log(&quot;notice the blank line before this function?&quot;);&#125;```syntax highlighting:```rubyrequire &apos;redcarpet&apos;markdown = Redcarpet.new(&quot;Hello World!&quot;)puts markdown.to_html``` Math BlocksYou can render LaTeX mathematical expressions using MathJax. Input $$, then press ‘Return’ key will trigger an input field which accept Tex/LaTex source. Following is an example:$$\mathbf{V}_1 \times \mathbf{V}_2 = \begin{vmatrix}\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \\frac{\partial X}{\partial u} &amp; \frac{\partial Y}{\partial u} &amp; 0 \\frac{\partial X}{\partial v} &amp; \frac{\partial Y}{\partial v} &amp; 0 \\end{vmatrix}$$In markdown source file, math block is LaTeX expression wrapped by ‘$$’ mark: 1234567$$\mathbf&#123;V&#125;_1 \times \mathbf&#123;V&#125;_2 = \begin&#123;vmatrix&#125; \mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp; \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\\end&#123;vmatrix&#125;$$ TablesInput | First Header | Second Header | and press return key will create a table with two column. After table is created, focus on that table will pop up a toolbar for table, where you can resize, align, or delete table. You can also use context menu to copy and add/delete column/row. Following descriptions can be skipped, as markdown source code for tables are generated by typora automatically. In markdown source code, they look like: 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | You can also include inline Markdown such as links, bold, italics, or strikethrough. Finally, by including colons : within the header row, you can define text to be left-aligned, right-aligned, or center-aligned: 12345| Left-Aligned | Center Aligned | Right Aligned || :------------ |:---------------:| -----:|| col 3 is | some wordy text | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | A colon on the left-most side indicates a left-aligned column; a colon on the right-most side indicates a right-aligned column; a colon on both sides indicates a center-aligned column. Footnotes123You can create footnotes like this[^footnote].[^footnote]: Here is the *text* of the **footnote**. will produce: You can create footnotes like this[^footnote]. [^footnote]: Here is the text of the footnote. Mouse on the ‘footnote’ superscript to see content of the footnote. Horizontal RulesInput *** or --- on a blank line and press return will draw a horizontal line. YAML Front MatterTypora support YAML Front Matter now. Input --- at the top of the article and then press Enter will introduce one. Or insert one metadata block from the menu. Table of Contents (TOC)Input [toc] then press Return key will create a section for “Table of Contents” extracting all headers from one’s writing, its contents will be updated automatically. Diagrams (Sequence, Flowchart and Mermaid)Typora supports, sequence, flowchart and mermaid, after this feature is enabled from preference panel. See this document for detail. Span ElementsSpan elements will be parsed and rendered right after your typing. Moving cursor in middle of those span elements will expand those elements into markdown source. Following will explain the syntax of those span element. LinksMarkdown supports two style of links: inline and reference. In both styles, the link text is delimited by [square brackets]. To create an inline link, use a set of regular parentheses immediately after the link text’s closing square bracket. Inside the parentheses, put the URL where you want the link to point, along with an optional title for the link, surrounded in quotes. For example: 123This is [an example](http://example.com/ "Title") inline link.[This link](http://example.net/) has no title attribute. will produce: This is an example inline link. (&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;) This link has no title attribute. (&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no) Internal LinksYou can set the href to headers, which will create a bookmark that allow you to jump to that section after clicking. For example: Command(on Windows: Ctrl) + Click This link will jump to header Block Elements. To see how to write that, please move cursor or click that link with ⌘ key pressed to expand the element into markdown source. Reference LinksReference-style links use a second set of square brackets, inside which you place a label of your choosing to identify the link: 12345This is [an example][id] reference-style link.Then, anywhere in the document, you define your link label like this, on a line by itself:[id]: http://example.com/ "Optional Title Here" In typora, they will be rendered like: This is an example reference-style link. The implicit link name shortcut allows you to omit the name of the link, in which case the link text itself is used as the name. Just use an empty set of square brackets — e.g., to link the word “Google” to the google.com web site, you could simply write: 1234[Google][]And then define the link:[Google]: http://google.com/ In typora click link will expand it for editing, command+click will open the hyperlink in web browser. URLsTypora allows you to insert urls as links, wrapped by &lt;brackets&gt;. &lt;i@typora.io&gt; becomes &#x69;&#64;&#x74;&#121;&#x70;&#111;&#x72;&#97;&#x2e;&#105;&#111;. Typora will aslo auto link standard URLs. e.g: www.google.com. ImagesImage looks similar with links, but it requires an additional ! char before the start of link. Image syntax looks like this: 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg "Optional title") You are able to use drag &amp; drop to insert image from image file or we browser. And modify the markdown source code by clicking on the image. Relative path will be used if image is in same directory or sub-directory with current editing document when drag &amp; drop. For more tips on images, please read http://support.typora.io//Images/ EmphasisMarkdown treats asterisks (*) and underscores (_) as indicators of emphasis. Text wrapped with one * or _ will be wrapped with an HTML &lt;em&gt; tag. E.g: 123*single asterisks*_single underscores_ output: single asterisks single underscores GFM will ignores underscores in words, which is commonly used in code and names, like this: wow_great_stuff do_this_and_do_that_and_another_thing. To produce a literal asterisk or underscore at a position where it would otherwise be used as an emphasis delimiter, you can backslash escape it: 1\*this text is surrounded by literal asterisks\* Typora recommends to use * symbol. Strongdouble *’s or _’s will be wrapped with an HTML &lt;strong&gt; tag, e.g: 123**double asterisks**__double underscores__ output: double asterisks double underscores Typora recommends to use ** symbol. CodeTo indicate a span of code, wrap it with backtick quotes (`). Unlike a pre-formatted code block, a code span indicates code within a normal paragraph. For example: 1Use the `printf()` function. will produce: Use the printf() function. StrikethroughGFM adds syntax to create strikethrough text, which is missing from standard Markdown. ~~Mistaken text.~~ becomes Mistaken text. UnderlineUnderline is powered by raw HTML. &lt;u&gt;Underline&lt;/u&gt; becomes Underline. Emoji :smile:Input emoji with syntax :smile:. User can trigger auto-complete suggestions for emoji by pressing ESC key, or trigger it automatically after enable it on preference panel. Also, input UTF8 emoji char directly from Edit -&gt; Emoji &amp; Symbols from menu bar is also supported. Inline MathTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use $ to wrap TeX command, for example: $\lim_{x \to \infty} \exp(-x) = 0$ will be rendered as LaTeX command. To trigger inline preview for inline math: input “$”, then press ESC key, then input TeX command, a preview tooltip will be visible like below: SubscriptTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use ~ to wrap subscript content, for example: H~2~O, X~long\ text~/ SuperscriptTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use ^ to wrap superscript content, for example: X^2^. HighlightTo use this feature, first, please enable it in Preference Panel -&gt; Markdown Tab. Then use == to wrap superscript content, for example: ==highlight==. HTMLYou could use HTML to style content what pure Markdown does not support, for example, use &lt;span style=&quot;color:red&quot;&gt;this text is red&lt;/span&gt; to add text with red color. Embed ContentsSome websites provide iframe-based embed code which you could also paste into Typora, for example: 1&lt;iframe height='265' scrolling='no' title='Fancy Animated SVG Menu' src='http://codepen.io/jeangontijo/embed/OxVywj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'&gt;&lt;/iframe&gt; VideoYou could use the &lt;video&gt; HTML tag to embed videos, for example: 1&lt;video src="xxx.mp4" /&gt; Other HTML SupportYou could find details here.]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown Typora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F18%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
